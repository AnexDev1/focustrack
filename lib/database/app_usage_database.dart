import 'package:drift/drift.dart';

part 'app_usage_database.g.dart'; // generated by drift_dev

// This will generate a table called "app_usage_sessions"
class AppUsageSessions extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get appName => text()();
  TextColumn get windowTitle => text().nullable()();
  DateTimeColumn get startTime => dateTime()();
  DateTimeColumn get endTime => dateTime().nullable()();
  IntColumn get durationMs => integer()(); // duration in milliseconds
  IntColumn get idleTimeMs =>
      integer().withDefault(const Constant(0))(); // idle time in milliseconds
  BoolColumn get isActive => boolean().withDefault(
    const Constant(false),
  )(); // to track current active session
}

@DriftDatabase(tables: [AppUsageSessions])
class AppUsageDatabase extends _$AppUsageDatabase {
  AppUsageDatabase(super.e);

  @override
  int get schemaVersion => 1;

  // Insert a new session
  Future<int> insertSession(AppUsageSessionsCompanion session) {
    return into(appUsageSessions).insert(session);
  }

  // Update a session
  Future<bool> updateSession(AppUsageSession session) {
    return update(appUsageSessions).replace(session);
  }

  // Get all sessions
  Future<List<AppUsageSession>> getAllSessions() {
    return select(appUsageSessions).get();
  }

  // Get sessions for a specific app
  Future<List<AppUsageSession>> getSessionsForApp(String appName) {
    return (select(
      appUsageSessions,
    )..where((tbl) => tbl.appName.equals(appName))).get();
  }

  // Get sessions for a date range
  Future<List<AppUsageSession>> getSessionsInDateRange(
    DateTime start,
    DateTime end,
  ) {
    return (select(
      appUsageSessions,
    )..where((tbl) => tbl.startTime.isBetweenValues(start, end))).get();
  }

  // Get today's sessions
  Future<List<AppUsageSession>> getTodaySessions() {
    final now = DateTime.now();
    final startOfDay = DateTime(now.year, now.month, now.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));
    return getSessionsInDateRange(startOfDay, endOfDay);
  }

  // Get yesterday's sessions
  Future<List<AppUsageSession>> getYesterdaySessions() {
    final now = DateTime.now();
    final yesterday = now.subtract(const Duration(days: 1));
    final startOfDay = DateTime(yesterday.year, yesterday.month, yesterday.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));
    return getSessionsInDateRange(startOfDay, endOfDay);
  }

  // Get this week's sessions
  Future<List<AppUsageSession>> getThisWeekSessions() {
    final now = DateTime.now();
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final startOfDay = DateTime(
      startOfWeek.year,
      startOfWeek.month,
      startOfWeek.day,
    );
    return getSessionsInDateRange(startOfDay, now);
  }

  // Get this month's sessions
  Future<List<AppUsageSession>> getThisMonthSessions() {
    final now = DateTime.now();
    final startOfMonth = DateTime(now.year, now.month, 1);
    return getSessionsInDateRange(startOfMonth, now);
  }

  // Get sessions grouped by day for a date range
  Future<Map<DateTime, List<AppUsageSession>>> getSessionsGroupedByDay(
    DateTime start,
    DateTime end,
  ) async {
    final sessions = await getSessionsInDateRange(start, end);
    final Map<DateTime, List<AppUsageSession>> grouped = {};

    for (var session in sessions) {
      final day = DateTime(
        session.startTime.year,
        session.startTime.month,
        session.startTime.day,
      );
      if (!grouped.containsKey(day)) {
        grouped[day] = [];
      }
      grouped[day]!.add(session);
    }

    return grouped;
  }

  // Get active session
  Future<AppUsageSession?> getActiveSession() {
    return (select(appUsageSessions)
          ..where((tbl) => tbl.isActive.equals(true))
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.startTime)]))
        .getSingleOrNull();
  }

  // Delete old sessions (cleanup)
  Future<int> deleteSessionsOlderThan(DateTime date) {
    return (delete(
      appUsageSessions,
    )..where((tbl) => tbl.startTime.isSmallerThanValue(date))).go();
  }

  // Delete all sessions
  Future<int> clearAllSessions() {
    return delete(appUsageSessions).go();
  }
}
